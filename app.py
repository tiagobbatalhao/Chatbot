#!/usr/bin/python
# coding: iso-8859-1

import os
import sys
import json
from datetime import datetime
import os
import urlparse
import psycopg2
from psycopg2 import sql
import requests
from flask import Flask, request, render_template

app = Flask(__name__)

# Custom modules
import setup_database
# import echo_confirmation
import chatbot_store as chatbot_behaviour

# Define API URLs
base_URL = 'https://graph.facebook.com/v2.6/'
url_messagingAPI = base_URL + 'me/messages'

# Some functions should be available only for testing
production = False

@app.route('/', methods=['GET'])
def verify():
    """
    When the endpoint is registered as a webhook, it must echo back
    the 'hub.challenge' value it receives in the query arguments.
    """
    if request.args.get('hub.mode') == 'subscribe' and request.args.get('hub.challenge'):
        if not request.args.get('hub.verify_token') == os.environ.get('VERIFY_TOKEN'):
            return 'Verification token mismatch', 403
        return request.args.get('hub.challenge'), 200
    # If the URL is accessed by third parties, print 'Hello World'
    return 'Hello world', 200

@app.route('/', methods=['POST'])
def webhook():
    """
    Endpoint for processing incoming messaging events.
    This is called when Facebook sends a POST request.
    Request comes with information about the message.
    """
    data = request.get_json()

    # # you may not want to log every incoming message in production,
    # but it's good for testing
    if not production:
        log(data)

    # Parse the message arguments and handle to a customized function
    if data['object'] == 'page':
        for entry in data.get('entry'):
            for message in entry.get('messaging'):
                message_info = message.get('message')
                quick_reply = message.get('message',{}).get('quick_reply')
                is_echo = message.get('message',{}).get('is_echo')
                if not is_echo:
                    # Save user to databse. If user exists, update it
                    # (User may have changed profile pic, for example)
                    id_sender = message.get('sender',{}).get('id')
                    add_new_user(id_sender)
                    user_info = get_user_information(id_sender)
                    update_user(user_info)

                if message_info and not is_echo and not quick_reply:
                    # This is a text message generated by the user

                    # Save message to databse
                    save_message(message)

                    # Customized function
                    # echo_confirmation.echo_confirmation(message,user_info)
                    chatbot_behaviour.answer(message, user_info)

                elif quick_reply:
                    # This is a quick-reply message
                    # Call a function with the same name as
                    # the first argument of the received payload.
                    # This allows us to direct the flow of the app
                    # directly from the payload messages.
                    payload = message.get('message',{}).get('quick_reply',{}).get('payload','')
                    payload = payload.split('-')
                    function = eval('chatbot_behaviour.' + payload[0])
                    function(message, user_info, payload = payload[1:])

                elif message.get('postback'):
                    # This is a postback message.
                    # Same behaviour as a quick_reply
                    payload = message.get('postback',{}).get('payload','')
                    payload = payload.split('-')
                    function = eval('chatbot_behaviour.' + payload[0])
                    function(message, user_info, payload = payload[1:])

    return 'OK', 200

def send_api(request_payload):
    """
    Basic function for sending a message
    """
    params = {'access_token': os.environ['PAGE_ACCESS_TOKEN']}
    headers = {'Content-Type': 'application/json'}
    response = requests.post(url_messagingAPI,
                        params=params,
                        headers=headers,
                        data=request_payload)
    if response.status_code != 200:
        log(response.status_code)
        log(response.text)
    return response

def send_text_message(id_recipient, message_text):
    """
    Send a text message to a user.
    """
    data = json.dumps({
        'messaging_type':'RESPONSE',
        'recipient': {'id': id_recipient},
        'message': {'text': message_text}
    },encoding='iso-8859-1')
    send_api(data)

def log(msg, *args, **kwargs):
    """
    Simple wrapper for logging to stdout on heroku
    """
    try:
        if type(msg) is dict:
            msg = json.dumps(msg)
        else:
            msg = unicode(msg,'iso-8859-1').format(*args, **kwargs)
    except TypeError,UnicodeEncodeError:
        # squash logging errors in case of non-ascii text
        pass
    print(u'{}: {}'.format(datetime.now(), msg))
    sys.stdout.flush()

################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
#
# SAVING MESSAGE INFORMATION
#
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################

def save_message(message):
    """
    Save information about a message to database.
    """
    params = [  message.get('message',{}).get('mid'),
                message.get('sender',{}).get('id'),
                message.get('recipient',{}).get('id'),
                message.get('message',{}).get('text'),
                message.get('timestamp'),
                message.get('message',{}).get('seq'),
                message.get('message',{}).get('quick_reply',{}).get('payload')]
    blanks = sql.SQL(u' , ').join([sql.SQL('%s')]*len(params))
    # command = sql.SQL(u"""
    #             INSERT INTO {} VALUES ( %s , %s , %s , %s , %s , %s, %s );
    #             """).format(sql.Identifier(u'messages'))
    command = sql.SQL(u"""
        INSERT INTO messages VALUES ( {} );
    """).format(blanks)
    database = setup_database.connect_database()
    cursor = database.cursor()
    try:
        execution = cursor.execute(command,params)
        database.commit()
    except psycopg2.IntegrityError:
        pass

    attachments = message.get('message',{}).get('attachments',[])
    # # Save the number of attachments
    # command = sql.SQL(u"""UPDATE {} SET {} = %s WHERE {} = %s;""").format(
    #     sql.Identifier('messages'),
    #     sql.Identifier('number_attachments'),
    #     sql.Identifier('id_message')
    # )
    # params = [len(attachments),message.get('message',{}).get('mid')]
    # try:
    #     execution = cursor.execute(command,params)
    #     database.commit()
    # except psycopg2.IntegrityError:
    #     pass

    # Save attachments
    for attachment in attachments:
        params = [  message.get('message',{}).get('mid'),
                    attachment.get('type'),
                    attachment.get('url') or attachment.get('payload',{}).get('url'),
                    attachment.get('payload',{}).get('coordinates',{}).get('lat'),
                    attachment.get('payload',{}).get('coordinates',{}).get('long'),
                    attachment.get('title') ]
        # command = sql.SQL(u"""
        #             INSERT INTO {} VALUES ( %s , %s , %s , %s , %s , %s);
        #             """).format(sql.Identifier('attachments'))
        blanks = sql.SQL(u' , ').join([sql.SQL(u'%s')]*len(params))
        command = sql.SQL(u"""
            INSERT INTO messages VALUES ( {} );
        """).format(blanks)
        try:
            execution = cursor.execute(command,params)
            database.commit()
        except psycopg2.IntegrityError:
            pass
    cursor.close()
    database.close()
    return 'OK', 200

################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
#
# SAVING USER INFORMATION
#
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################

def get_user_information(id_user):
    """
    Return basic information about a user
    """
    url_query = base_URL + id_user
    fields = []
    fields.append('first_name')
    fields.append('last_name')
    fields.append('profile_pic')
    fields.append('locale')
    fields.append('timezone')
    fields.append('gender')
    payload = {'fields':','.join(fields),
                'access_token': os.environ['PAGE_ACCESS_TOKEN']}
    r = requests.get(url_query,params=payload)
    data = r.json()
    return data

def add_new_user(id_user):
    """
    Add a new user to database.
    """
    command = sql.SQL(u"""
        INSERT INTO users ( id ) VALUES ( %s );
    """)
    params = [id_user]
    database = setup_database.connect_database()
    cursor = database.cursor()
    try:
        execution = cursor.execute(command,params)
        database.commit()
    except psycopg2.IntegrityError:
        pass
    cursor.close()
    database.close()

def update_user(user_info):
    """
    Update details about an existing user.
    """
    set_commands = [sql.SQL('{} = %s').format(sql.Identifier(name)) for name in user_info]
    set_clause = sql.SQL(' , ').join(set_commands)
    command = sql.SQL(u"""
        UPDATE users SET {} WHERE id = %s;
    """).format(set_clause)
    params = [value for name,value in user_info.items()] + [user_info['id']]
    database = setup_database.connect_database()
    cursor = database.cursor()
    try:
        execution = cursor.execute(command,params)
        database.commit()
    except psycopg2.DataError:
        pass
    cursor.close()
    database.close()

################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
#
# FUNCTIONS FOR SETUP AND TEST
#
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################

if not production:
    @app.route('/check_database', methods=['GET'])
    def check_database():
        """
        ONLY FOR TESTING.
        Display the number of records on database.
        """
        return setup_database.check_database()

    @app.route('/reset_database', methods=['GET'])
    def reset_database():
        """
        ONLY FOR TESTING.
        Reset the database to empty.
        """
        return setup_database.reset_database()

    @app.route('/create_persistent_menu', methods=['GET'])
    def create_persistent_menu():
        """
        ONLY FOR TESTING.
        Setup the chatbot's persistent menu.
        """
        url_profileAPI = base_URL + 'me/messenger_profile'
        params = {'access_token': os.environ['PAGE_ACCESS_TOKEN']}
        headers = {'Content-Type': 'application/json'}
        data = chatbot_behaviour.setup_persistent_menu()
        r = requests.post(url_profileAPI,
                            params=params,
                            headers=headers,
                            data=json.dumps(data,encoding='iso-8859-1'))
        if r.status_code != 200:
            log(r.status_code)
            log(r.text)
        return 'OK', 200

    @app.route('/save_products', methods=['GET'])
    def save_products():
        """
        ONLY FOR TESTING.
        Read a CSV file and populate the 'products' table.
        In a real system, the 'products' table is managed by a different entity.
        The chatbot should have only 'read' permission on this table.
        """
        chatbot_behaviour.products_available()
        return 'OK', 200

def upload_photo():
    """
    ONLY FOR TESTING.
    Upload my photo to Facebook.
    Because it might be sent to several users,
    it's better to upload it to Facebook once
    and refer to it by only the id
    """
    url_upload = base_URL + 'me/message_attachments'
    attach = {
        'type': 'image',
        'payload': {
            'is_reusable': True,
            'url': chatbot_behaviour.url_AWSbucket + 'TiagoProfile.jpg'
        }
    }
    data = json.dumps({
        'message': {'attachment': attach}
    },encoding='iso-8859-1')

    params = {'access_token': os.environ['PAGE_ACCESS_TOKEN']}
    headers = {'Content-Type': 'application/json'}
    response = requests.post(url_upload,
                        params=params,
                        headers=headers,
                        data=data)
    if response.status_code != 200:
        log(response.status_code)
        log(response.text)
    attachment_id = response.json().get('attachment_id')
    return attachment_id

if 'profile_photo_id' not in locals():
    profile_photo_id = upload_photo()

################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
#
# PRIVACY POLICY
#
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################

@app.route('/privacy_policy', methods=['GET'])
def privacy_policy():
    return render_template('termsfeed-privacy-policy-html-english.html')


################################################################################
################################################################################
################################################################################
################################################################################
################################################################################
#
# RUNNING FROM COMMAND LINE
#
################################################################################
################################################################################
################################################################################
################################################################################
################################################################################

if __name__ == '__main__':
    app.run(debug=True)
